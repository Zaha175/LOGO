<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kerr 5D Gateway Modul</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    
    #info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #00ff99;
      font-size: 14px;
      background-color: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
      opacity: 0.7;
      pointer-events: none;
      z-index: 100;
      display: none;
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff99;
      font-size: 18px;
      text-align: center;
    }
    
    .control-panel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }
    
    .control-button {
      background-color: #00997f;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .control-button:hover {
      background-color: #00ff99;
    }
    
    @media (prefers-color-scheme: dark) {
      body { background-color: #000; }
    }
  </style>
</head>
<body>
  <div id="loading">Initialisiere Kerr 5D Gateway...</div>
  <div id="info">Kerr 5D Gateway Modul - Aktiviert</div>
  <div class="control-panel">
    <button class="control-button" id="toggleAudio">Audio Ein/Aus</button>
    <button class="control-button" id="toggleColors">Farbschema</button>
  </div>
  
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
    
    // DOM-Elemente
    const infoElement = document.getElementById('info');
    const loadingElement = document.getElementById('loading');
    const toggleAudioButton = document.getElementById('toggleAudio');
    const toggleColorsButton = document.getElementById('toggleColors');
    
    // Erzeugen eines synthetischen Kerr-5D-Parameter-Datensatzes
    const generateKerrParams = () => {
      const params = [];
      for (let i = 0; i < 100; i++) {
        params.push({
          curvature: 5 + Math.sin(i * 0.1) * 4,
          energy_flow: 0.5 + Math.sin(i * 0.2) * 0.4,
          mass_density: 0.8 + Math.cos(i * 0.15) * 0.2,
          rotation_factor: 1 + Math.sin(i * 0.05) * 0.3
        });
      }
      return params;
    };
    
    // Kerr-Parameter
    const kerrParams = generateKerrParams();
    
    // Grundlegendes 3D-Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000510, 0.035);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    // Neuere THREE.js Versionen verwenden outputColorSpace statt outputEncoding
    if (THREE.ColorManagement) {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else {
      // Fallback für ältere Versionen
      renderer.outputEncoding = THREE.sRGBEncoding || 3000;
    }
    renderer.toneMapping = THREE.ACESFilmicToneMapping || 5;
    document.body.appendChild(renderer.domElement);
    
    // Post-Processing für Glow-Effekte
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,   // Stärke
      0.4,   // Radius
      0.85   // Threshold
    );
    
    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
    
    // Farbpaletten für Schemawechsel
    const colorSchemes = [
      { ring: 0x00ff99, vortex: 0x0044ff, particles: 0xffffff },
      { ring: 0xff6600, vortex: 0x9900ff, particles: 0xffff00 },
      { ring: 0x00ffff, vortex: 0xff0066, particles: 0x66ff00 }
    ];
    let currentColorScheme = 0;
    
    // Kerr-Ring mit verbessertem Material
    const ringGeometry = new THREE.TorusGeometry(5, 0.8, 32, 100);
    const ringMaterial = new THREE.MeshPhysicalMaterial({ 
      color: colorSchemes[currentColorScheme].ring, 
      emissive: colorSchemes[currentColorScheme].ring,
      emissiveIntensity: 0.5,
      metalness: 0.9,
      roughness: 0.2,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
      envMapIntensity: 1.0
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    scene.add(ring);
    
    // Innerer Ring für zusätzliche Tiefe
    const innerRingGeometry = new THREE.TorusGeometry(4, 0.4, 24, 80);
    const innerRingMaterial = new THREE.MeshPhysicalMaterial({ 
      color: 0xffffff,
      emissive: colorSchemes[currentColorScheme].ring,
      transparent: true,
      opacity: 0.7,
      metalness: 0.9,
      roughness: 0.2,
      clearcoat: 1.0
    });
    const innerRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
    innerRing.rotation.x = Math.PI / 2;
    scene.add(innerRing);
    
    // Verbesserter 5D-Gateway-Vortex
    const vortexGeometry = new THREE.IcosahedronGeometry(3, 3);
    const vortexMaterial = new THREE.MeshPhysicalMaterial({
      color: colorSchemes[currentColorScheme].vortex,
      emissive: colorSchemes[currentColorScheme].vortex,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.4,
      metalness: 0.8,
      roughness: 0.2,
      clearcoat: 1.0,
      wireframe: false,
      side: THREE.DoubleSide
    });
    const vortex = new THREE.Mesh(vortexGeometry, vortexMaterial);
    scene.add(vortex);
    
    // Wireframe-Schicht des Vortex
    const vortexWireframeGeometry = new THREE.IcosahedronGeometry(3.2, 2);
    const vortexWireframeMaterial = new THREE.MeshBasicMaterial({
      color: colorSchemes[currentColorScheme].vortex,
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });
    const vortexWireframe = new THREE.Mesh(vortexWireframeGeometry, vortexWireframeMaterial);
    scene.add(vortexWireframe);
    
    // Optimierte Teilchenströme mit PointsMaterial
    const particleCount = 500;
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    const particleColors = new Float32Array(particleCount * 3);
    const particleData = [];
    
    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 2 + Math.random() * 3.5;
      const height = -3 + Math.random() * 6;
      const speed = 0.005 + Math.random() * 0.01;
      const size = 0.05 + Math.random() * 0.15;
      const rIndex = Math.floor(Math.random() * kerrParams.length);
      const spiral = Math.random() > 0.5;
      
      particleData.push({
        angle, radius, height, speed, rIndex, spiral, 
        phase: Math.random() * Math.PI * 2
      });
      
      particlePositions[i * 3] = Math.cos(angle) * radius;
      particlePositions[i * 3 + 1] = height;
      particlePositions[i * 3 + 2] = Math.sin(angle) * radius;
      
      particleSizes[i] = size;
      
      // Farbvariation für die Partikel
      const blue = Math.random() * 0.5 + 0.5;
      particleColors[i * 3] = 1;
      particleColors[i * 3 + 1] = 1;
      particleColors[i * 3 + 2] = blue;
    }
    
    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    
    const particleTexture = new THREE.TextureLoader().load(
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAFFmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMzFUMTU6NTE6MjItMDc6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTMxVDE2OjM3OjA2LTA3OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTMxVDE2OjM3OjA2LTA3OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmE4MjI1NTM0LWU3MDktNGZiMi05ZTA0LTU2MzI1MDBkODYwNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDphODIyNTUzNC1lNzA5LTRmYjItOWUwNC01NjMyNTAwZDg2MDUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODIyNTUzNC1lNzA5LTRmYjItOWUwNC01NjMyNTAwZDg2MDUiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmE4MjI1NTM0LWU3MDktNGZiMi05ZTA0LTU2MzI1MDBkODYwNSIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0zMVQxNTo1MToyMi0wNzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8oo7vwAAAelJREFUWIXtl79qFEEcxz/f2ZCD/JGDEzk82AgSA8YUaRKwshEsLEQiPoGIjb5BiDyAraXYCGpEK4s0KURMlXBqjGcIQeK5nsaQ5C7jFrdZdndn9i5NwH5hmWVmfr/vZ3+/mdnCzCiynAtVfTKbtaKVn2QWwEAVYGY5r5aAXWAPGC/CxsyG5uigqijZPSB7wYsciALILQJmNqq9JyCxCMQuQeIkZA7ExEBc0XAp6QwkDsQchWF+kB0HUgdiCuQHqX6QWgfiPCCtCkLvgHH4LjPLm/UPEDW+qsoA18GqGkqHgdAiMwfGO2pqG9sCHoGDpgHUUruqnqGb9IGPZ3qAqt4FfgJXgQcFcTAN7AITqroSgHkFvAQGwLyqLpjZl24nUtUr2cNPgZs1kFVgBKyZ2VZmvwM8b7F9BLzJ7Gtm9q3SWVXLwDqwDFxv8fEZeJIN/GZmh5m9W0H2gbu12BkCt1v6F5m2vWCvSU+yYoGLjbhuYNzuA31gG/gLvMA5ZnYkIgvAb+7jNP4I3AFeicgn59x+u4Oi8Ai41xJhY4dXOIlxKCJ3gPWsS8c4vMTsiEbAOyB2wUvA59gPXxpKRGSKuhtwHhtm9ip2kJgWqavBFM4VJL4IKk0HgAuF/x2P3YHY9xJ1cZSzh4j8A9GgcTL1WEruAAAAAElFTkSuQmCC'
    );
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 0.5,
      map: particleTexture,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);
    
    // Kernpartikel im Zentrum
    const coreParticles = new THREE.Points(
      new THREE.SphereGeometry(1.5, 32, 32),
      new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.08,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      })
    );
    scene.add(coreParticles);
    
    // Äußere Atmosphäre
    const atmosphereGeometry = new THREE.SphereGeometry(8, 32, 32);
    const atmosphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x001133,
      transparent: true,
      opacity: 0.1,
      side: THREE.BackSide
    });
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    scene.add(atmosphere);
    
    // Verbesserte Beleuchtung
    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);
    
    const pointLight1 = new THREE.PointLight(colorSchemes[currentColorScheme].ring, 2, 20);
    pointLight1.position.set(5, 5, 5);
    scene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(colorSchemes[currentColorScheme].vortex, 2, 15);
    pointLight2.position.set(-5, -5, 5);
    scene.add(pointLight2);
    
    // Audio
    const listener = new THREE.AudioListener();
    camera.add(listener);
    
    const sound = new THREE.Audio(listener);
    const audioLoader = new THREE.AudioLoader();
    let audioLoaded = false;
    let audioPlaying = false;
    
    audioLoader.load('https://cdn.pixabay.com/audio/2022/03/15/audio_d4e5c26ba5.mp3', buffer => {
      sound.setBuffer(buffer);
      sound.setLoop(true);
      sound.setVolume(0.3);
      audioLoaded = true;
      loadingElement.style.display = 'none';
    }, 
    // Progress-Callback
    (xhr) => {
      loadingElement.textContent = `Lade Audio: ${Math.round(xhr.loaded / xhr.total * 100)}%`;
    },
    // Error-Callback
    (err) => {
      console.error('Audio konnte nicht geladen werden:', err);
      loadingElement.style.display = 'none';
    });
    
    // Raycaster und Mouse-Interaktion
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Interaktion
    let isActivated = false;
    let mouseOverVortex = false;
    
    // Event-Listener
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(vortex);
      
      if (intersects.length > 0) {
        if (!mouseOverVortex) {
          document.body.style.cursor = 'pointer';
          mouseOverVortex = true;
          vortexMaterial.emissiveIntensity = 0.8;
        }
      } else {
        if (mouseOverVortex) {
          document.body.style.cursor = 'default';
          mouseOverVortex = false;
          vortexMaterial.emissiveIntensity = isActivated ? 0.6 : 0.5;
        }
      }
    });
    
    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(vortex);
      
      if (intersects.length > 0) {
        toggleGateway();
      }
    });
    
    function toggleGateway() {
      isActivated = !isActivated;
      
      if (isActivated) {
        vortexMaterial.emissiveIntensity = 0.7;
        ringMaterial.emissiveIntensity = 0.7;
        bloomPass.strength = 2;
        infoElement.style.display = 'block';
        
        // Audio starten wenn geladen
        if (audioLoaded && !audioPlaying) {
          sound.play();
          audioPlaying = true;
        }
      } else {
        vortexMaterial.emissiveIntensity = 0.5;
        ringMaterial.emissiveIntensity = 0.5;
        bloomPass.strength = 1.5;
        infoElement.style.display = 'none';
        
        if (audioPlaying) {
          sound.pause();
          audioPlaying = false;
        }
      }
    }
    
    // Audio-Button
    toggleAudioButton.addEventListener('click', () => {
      if (!audioLoaded) return;
      
      if (audioPlaying) {
        sound.pause();
        audioPlaying = false;
        toggleAudioButton.textContent = 'Audio Ein';
      } else {
        sound.play();
        audioPlaying = true;
        toggleAudioButton.textContent = 'Audio Aus';
      }
    });
    
    // Farbschema-Button
    toggleColorsButton.addEventListener('click', () => {
      currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
      
      // Farben aktualisieren
      ringMaterial.color.set(colorSchemes[currentColorScheme].ring);
      ringMaterial.emissive.set(colorSchemes[currentColorScheme].ring);
      innerRingMaterial.emissive.set(colorSchemes[currentColorScheme].ring);
      
      vortexMaterial.color.set(colorSchemes[currentColorScheme].vortex);
      vortexMaterial.emissive.set(colorSchemes[currentColorScheme].vortex);
      vortexWireframeMaterial.color.set(colorSchemes[currentColorScheme].vortex);
      
      pointLight1.color.set(colorSchemes[currentColorScheme].ring);
      pointLight2.color.set(colorSchemes[currentColorScheme].vortex);
    });
    
    // Fenster-Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Animationsschleife
    let clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      
      // Dynamische Pulsation basierend auf Kerr-Krümmung
      const curvatureIndex = Math.floor(t * 5) % kerrParams.length;
      const curvature = kerrParams[curvatureIndex].curvature / 10;
      const scale = 1 + Math.sin(t * 1.2) * 0.08 * curvature;
      
      vortex.scale.set(scale, scale, scale);
      vortexWireframe.scale.set(scale * 1.05, scale * 1.05, scale * 1.05);
      
      // Ring-Rotation
      ring.rotation.x = Math.sin(t * 0.2) * 0.3;
      ring.rotation.y += 0.003;
      ring.rotation.z += 0.001;
      
      innerRing.rotation.x += 0.005;
      innerRing.rotation.z = Math.sin(t * 0.3) * 0.5;
      
      // Vortex-Rotation
      vortex.rotation.y -= 0.002;
      vortex.rotation.z = Math.sin(t * 0.5) * 0.1;
      vortexWireframe.rotation.y += 0.001;
      vortexWireframe.rotation.x = Math.sin(t * 0.3) * 0.1;
      
      // Kern-Rotation
      coreParticles.rotation.y += 0.01;
      coreParticles.rotation.x = Math.sin(t * 0.5) * 0.2;
      
      // Teilchen aktualisieren
      const positions = particleGeometry.attributes.position.array;
      const colors = particleGeometry.attributes.color.array;
      
      for (let i = 0; i < particleCount; i++) {
        const particle = particleData[i];
        const energyFlow = kerrParams[particle.rIndex].energy_flow;
        const massEffect = kerrParams[particle.rIndex].mass_density;
        
        // Teilchenbewegung mit Spiralweg
        particle.angle += particle.speed * energyFlow;
        
        if (particle.spiral) {
          particle.radius = 2 + Math.sin(particle.angle * 0.2) * 3.5 * massEffect;
          particle.height = Math.cos(particle.angle * 0.3) * 3 * massEffect;
        }
        
        positions[i * 3] = Math.cos(particle.angle) * particle.radius;
        positions[i * 3 + 1] = particle.height;
        positions[i * 3 + 2] = Math.sin(particle.angle) * particle.radius;
        
        // Farbe pulsieren lassen
        const colorPhase = (t + particle.phase) * 2;
        const red = 0.7 + Math.sin(colorPhase) * 0.3;
        const green = 0.7 + Math.sin(colorPhase + 2) * 0.3;
        const blue = 0.7 + Math.sin(colorPhase + 4) * 0.3;
        
        colors[i * 3] = red;
        colors[i * 3 + 1] = green;
        colors[i * 3 + 2] = blue;
      }
      
      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;
      
      // Rendering mit Bloom-Effekt
      composer.render();
    }
    
    // Animation starten
    animate();
  </script>
</body>
</html>
